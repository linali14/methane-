<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit 5 Assignment: Methane Molecule (CH4) Model</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        canvas { display: block; }
        .controls {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            font-family: sans-serif;
            color: #333;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            text-align: center;
            font-size: 14px;
        }
        .controls strong { color: #880000; }
    </style>
    <!-- Removed old, error-prone CDN script tags -->
</head>
<body>
<div class="controls">
    <p>Methane Molecule ($\text{CH}_4$) - **Rotating Model**</p>
    <p>Use **Click and Drag** to manually rotate the molecule and label together.</p>
</div>
<!-- All Three.js functionality is now loaded via ES Modules for stability -->
<script type="module">
    // Import core Three.js components
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.156.0/build/three.module.js';
    // Import extensions using the jsm path, making them available as FontLoader and TextGeometry
    import { FontLoader } from 'https://cdn.jsdelivr.net/npm/three@0.156.0/examples/jsm/loaders/FontLoader.js';
    import { TextGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.156.0/examples/jsm/geometries/TextGeometry.js';
    
    // The main execution block
    
    // --- Global Setup ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });

    // Enable shadows in the renderer
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true; 
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // Camera Positioning
    camera.position.set(0, 2, 5);
    camera.lookAt(0, 0, 0);

    // --- Colors and Dimensions ---
    const CARBON_COLOR = 0xcc0000; // Red tone for Carbon
    const HYDROGEN_COLOR = 0x0040ff; // Blue tone for Hydrogen
    const BOND_COLOR = 0xffffff; // White for bonds
    const BOND_EMISSIVE = 0xcccccc; // Light gray for bond emissive

    const PLANE_COLOR = 0x00aa00; // Green color for the plane

    const RADIUS_C = 0.6; // Carbon atom radius
    const RADIUS_H = 0.3; // Hydrogen atom radius
    const BOND_LENGTH = 2.0; // Distance from center C to center H
    const BOND_THICKNESS = 0.1;
    const PLANE_Y_POSITION = -RADIUS_C - 0.1; // Plane position slightly below the carbon center

    // --- Lighting ---
    
    // 1. Ambient Light: Soft, overall illumination
    const ambientLight = new THREE.AmbientLight(0x404040, 1.5); 
    scene.add(ambientLight);

    // 2. Directional Light (Sun): Primary light source, essential for shadows
    const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
    directionalLight.position.set(10, 15, 10);
    
    // Enable shadow casting for this light source
    directionalLight.castShadow = true; 
    
    // Configure shadow map size and frustum 
    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 50;
    directionalLight.shadow.camera.left = -10;
    directionalLight.shadow.camera.right = 10;
    directionalLight.shadow.camera.top = 10;
    directionalLight.shadow.camera.bottom = -10;
    
    scene.add(directionalLight);

    // --- Green Plane (The ground) ---
    const plane_geometry = new THREE.PlaneGeometry(30, 30);
    // Use MeshPhongMaterial for the plane so it can receive shadows
    const plane_material = new THREE.MeshPhongMaterial({ color: PLANE_COLOR, side: THREE.DoubleSide });
    const plane = new THREE.Mesh(plane_geometry, plane_material);
    plane.rotation.x = -Math.PI / 2; // Rotate to lie flat
    plane.position.y = PLANE_Y_POSITION; // Position under the molecule
    plane.receiveShadow = true; 
    plane.castShadow = false;
    scene.add(plane);

    // --- Methane Geometry and Structure ($\text{CH}_4$) ---

    // The molecular group will hold all atoms, bonds, and the label.
    const methaneGroup = new THREE.Group();
    // The group itself will manage casting shadows for all children
    
    // 1. Carbon Atom (Center)
    const c_geometry = new THREE.SphereGeometry(RADIUS_C, 32, 32);
    const c_material = new THREE.MeshPhongMaterial({ color: CARBON_COLOR });
    const carbon = new THREE.Mesh(c_geometry, c_material);
    carbon.position.set(0, 0, 0);
    carbon.castShadow = true; 
    carbon.receiveShadow = true; 
    methaneGroup.add(carbon);

    // Define the tetrahedral positions for the Hydrogen atoms
    const H_positions = [
        new THREE.Vector3(1, 1, 1).normalize().multiplyScalar(BOND_LENGTH),
        new THREE.Vector3(-1, -1, 1).normalize().multiplyScalar(BOND_LENGTH),
        new THREE.Vector3(-1, 1, -1).normalize().multiplyScalar(BOND_LENGTH),
        new THREE.Vector3(1, -1, -1).normalize().multiplyScalar(BOND_LENGTH)
    ];

    const h_geometry = new THREE.SphereGeometry(RADIUS_H, 32, 32);
    const h_material = new THREE.MeshPhongMaterial({ color: HYDROGEN_COLOR });
    const bond_geometry = new THREE.CylinderGeometry(BOND_THICKNESS, BOND_THICKNESS, BOND_LENGTH - RADIUS_C - RADIUS_H, 8);
    const bond_material = new THREE.MeshPhongMaterial({ 
        color: BOND_COLOR, 
        emissive: BOND_EMISSIVE, 
        emissiveIntensity: 0.3
    });

    // 2. Hydrogen Atoms and Bonds (4x)
    H_positions.forEach(pos => {
        // --- Hydrogen Atom ---
        const hydrogen = new THREE.Mesh(h_geometry, h_material);
        hydrogen.position.copy(pos);
        hydrogen.castShadow = true;
        hydrogen.receiveShadow = true;
        methaneGroup.add(hydrogen);

        // --- Bond (Cylinder) ---
        const bond = new THREE.Mesh(bond_geometry, bond_material);
        bond.castShadow = true;
        bond.receiveShadow = true;
        
        // Position and orient the bond 
        bond.position.copy(pos).multiplyScalar(0.5);
        const direction = new THREE.Vector3().copy(pos).normalize();
        const axis = new THREE.Vector3(0, 1, 0);
        const quaternion = new THREE.Quaternion();
        quaternion.setFromUnitVectors(axis, direction);
        bond.setRotationFromQuaternion(quaternion);

        methaneGroup.add(bond);
    });

    // --- Methane Label ($\text{CH}_4$) ---
    
    // FontLoader is now imported directly, not accessed through THREE.
    const loader = new FontLoader(); 
    
    // Load a font (using built-in helvetiker_regular for simplicity)
    loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
        
        // Text configuration for "CH4"
        const textOptions = {
            font: font,
            size: 0.8,
            height: 0.1, // Small extrusion for 3D depth
            curveSegments: 12
        };
        
        // Material for the text, so it can cast shadows
        const textMaterial = new THREE.MeshPhongMaterial({ color: 0x444444, shininess: 30 });

        // Geometry for "CH" - TextGeometry is now imported directly.
        const chGeometry = new TextGeometry('CH', textOptions); 
        chGeometry.computeBoundingBox();
        const ch = new THREE.Mesh(chGeometry, textMaterial);
        ch.castShadow = true;
        ch.receiveShadow = true;
        
        // Geometry for the subscript "4" - TextGeometry is now imported directly.
        const sub4Options = { ...textOptions, size: 0.4, height: 0.05 };
        const sub4Geometry = new TextGeometry('4', sub4Options); 
        sub4Geometry.computeBoundingBox();
        const sub4 = new THREE.Mesh(sub4Geometry, textMaterial);
        sub4.castShadow = true;
        sub4.receiveShadow = true;

        // Position the subscript '4' relative to 'CH'
        const chWidth = chGeometry.boundingBox.max.x - chGeometry.boundingBox.min.x;
        sub4.position.x = chWidth - 0.1; // Place it next to CH
        sub4.position.y = -0.3; // Drop it down for subscript look
        
        // Create a separate group for the label text components
        const labelGroup = new THREE.Group();
        labelGroup.add(ch);
        labelGroup.add(sub4);
        
        // Center the entire label group horizontally (using CH width as a proxy)
        const labelWidth = chWidth + (sub4Options.size / 2); // Approximate total width
        labelGroup.position.x = -labelWidth / 2 + 0.1; 
        
        // Position the label below the molecule, just above the plane
        labelGroup.position.y = PLANE_Y_POSITION + 0.1; 
        labelGroup.rotation.x = -Math.PI * 0.1; // Tilt slightly for better 3D effect
        
        // Add the label to the Methane group so it rotates with the molecule
        methaneGroup.add(labelGroup);
        
        // Ensure animate starts after the font is loaded, as the label is critical.
        animate();
    }, (xhr) => {
        // Optional: Progress tracking
    }, (error) => {
        // Handle font loading error
        console.error('An error occurred while loading the font:', error);
        // Start animation anyway, without the label
        animate();
    });

    // Add the fully constructed molecule group to the scene
    scene.add(methaneGroup);

    // --- Interactivity (Mouse Controls) ---

    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    const rotationSpeed = 0.01;

    // Mouse Down: Start dragging
    renderer.domElement.addEventListener('mousedown', (e) => {
        isDragging = true;
        previousMousePosition.x = e.clientX;
        previousMousePosition.y = e.clientY;
    });

    // Mouse Move: Apply rotation to the METHANE GROUP only
    renderer.domElement.addEventListener('mousemove', (e) => {
        if (!isDragging) return;

        const deltaX = e.clientX - previousMousePosition.x;
        const deltaY = e.clientY - previousMousePosition.y;

        // Rotate the methaneGroup around the global Y-axis
        methaneGroup.rotation.y += deltaX * rotationSpeed;
        
        // Rotate the methaneGroup around the local X-axis
        methaneGroup.rotation.x += deltaY * rotationSpeed;
        
        previousMousePosition.x = e.clientX;
        previousMousePosition.y = e.clientY;
    });

    // Mouse Up: Stop dragging
    renderer.domElement.addEventListener('mouseup', () => {
        isDragging = false;
    });
    
    // Touch event handlers for mobile devices
    renderer.domElement.addEventListener('touchstart', (e) => {
        e.preventDefault();
        isDragging = true;
        const touch = e.touches[0];
        previousMousePosition.x = touch.clientX;
        previousMousePosition.y = touch.clientY;
    });

    renderer.domElement.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (!isDragging) return;
        const touch = e.touches[0];
        
        const deltaX = touch.clientX - previousMousePosition.x;
        const deltaY = touch.clientY - previousMousePosition.y;

        methaneGroup.rotation.y += deltaX * rotationSpeed;
        methaneGroup.rotation.x += deltaY * rotationSpeed;
        
        previousMousePosition.x = touch.clientX;
        previousMousePosition.y = touch.clientY;
    });

    renderer.domElement.addEventListener('touchend', () => {
        isDragging = false;
    });

    // --- Animation Loop ---

    function animate() {
        requestAnimationFrame(animate);

        // Auto-animation: gentle rotation only when the user is not dragging
        if (!isDragging) {
            methaneGroup.rotation.y += 0.005; 
        }
        
        renderer.render(scene, camera);
    }

    // Since font loading is asynchronous, we need to ensure the animation
    // loop is called after the font load succeeds or fails.
    // The call to animate() has been moved inside the loader.load callback.

</script>
</body>
</html>
